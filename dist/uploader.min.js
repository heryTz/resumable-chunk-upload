(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // uploader.js
  var Uploader = class {
    baseUrl = null;
    file = null;
    fileId = "";
    chunkNumber = 1;
    chunkSize = 10485760;
    chunkCount = 1;
    lastChunkUploadedPath = "/lastChunkUploaded";
    uploadPath = "/upload";
    progressTimeout = 3e3;
    xhr = new XMLHttpRequest();
    remainingTimeCalculator = new RemainingTimeCalculator(new Date(), 0);
    uploadAborted = false;
    headers = {};
    onProgress = () => {
    };
    getLastChunkUploaded = async () => {
      return new Promise((resolve, reject) => {
        this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
        const params = queryParams({
          fileId: this.getFileId(),
          chunkCount: this.chunkCount
        });
        const xhr = new XMLHttpRequest();
        xhr.open("GET", `${this.baseUrl}${this.lastChunkUploadedPath}?${params}`, true);
        xhr.responseType = "json";
        Object.keys(this.headers).forEach((key) => {
          xhr.setRequestHeader(key, this.headers[key]);
        });
        xhr.onerror = xhr.onabort = () => {
          reject(new UploadError(UploadError.GET_LAST_CHUNK_UPLOADED, xhr));
        };
        xhr.onload = () => {
          if (xhr.status === 200) {
            resolve(xhr.response.lastChunk);
          } else {
            reject(new UploadError(UploadError.GET_LAST_CHUNK_UPLOADED, xhr));
          }
        };
        xhr.send();
      });
    };
    uploadFile = async () => {
      return new Promise((resolve, reject) => {
        const xhr = this.xhr;
        xhr.open("POST", `${this.baseUrl}${this.uploadPath}`, true);
        xhr.responseType = "json";
        Object.keys(this.headers).forEach((key) => {
          xhr.setRequestHeader(key, this.headers[key]);
        });
        const form = new FormData();
        form.append("file", this.getChunk());
        form.append("fileId", this.getFileId());
        form.append("chunkCount", this.chunkCount);
        form.append("chunkSize", this.chunkSize);
        form.append("chunkNumber", this.chunkNumber);
        form.append("fileSize", this.file.size);
        form.append("originalFilename", this.file.name);
        xhr.onload = xhr.onerror = (e) => {
          if (xhr.status === 200) {
            this.chunkNumber++;
            if (this.chunkNumber <= this.chunkCount) {
              this.uploadFile().then(resolve).catch(reject);
            } else {
              resolve(xhr);
            }
          } else {
            this.chunkNumber = 1;
            reject(new UploadError(UploadError.UPLOAD_FILE_ERROR, xhr));
          }
        };
        xhr.onabort = (e) => {
          this.chunkNumber = 1;
          reject(new UploadError(UploadError.UPLOAD_ABORTED, xhr));
        };
        xhr.upload.onprogress = throttle((e) => {
          if (this.uploadAborted)
            return;
          const chunkAlreadyUploaded = (this.chunkNumber - 1) * this.chunkSize;
          const loaded = chunkAlreadyUploaded + e.loaded;
          const total = this.file.size;
          const percent = Math.min(Math.ceil(loaded / total * 100), 100);
          this.onProgress && this.onProgress({
            percent,
            loaded,
            remaining: this.remainingTimeCalculator.increaseBytesUploaded(e.loaded).calcul(this.chunkLoaded)
          });
        }, this.progressTimeout);
        xhr.send(form);
      });
    };
    upload = async () => {
      try {
        const lastChunk = await this.getLastChunkUploaded();
        this.chunkNumber = lastChunk + 1;
        const restByteToUpload = this.file.slice((this.chunkNumber - 1) * this.chunkSize).size;
        this.remainingTimeCalculator = new RemainingTimeCalculator(new Date(), restByteToUpload);
        this.uploadAborted = false;
        return await this.uploadFile();
      } catch (e) {
        throw e;
      }
    };
    onProgress = (callback, debounceTime) => {
      this.onProgress = callback;
      if (debounceTime >= 0)
        this.progressTimeout = parseInt(debounceTime);
      return this;
    };
    abort = () => {
      this.uploadAborted = true;
      this.xhr.abort();
    };
    getChunk = () => {
      let startSize = (this.chunkNumber - 1) * this.chunkSize;
      let endSize = Math.min(startSize + this.chunkSize, this.file.size);
      return this.file.slice(startSize, endSize);
    };
    getFileId = () => {
      const ext = this.file.name.split(".").pop();
      const defaultId = `${this.file.size}-${this.file.lastModified}.${ext}`;
      return this.fileId || defaultId;
    };
    setBaseUrl = (url) => {
      this.baseUrl = removeTrailingSlash(url);
      return this;
    };
    setFile = (file) => {
      this.file = file;
      return this;
    };
    setChunkSize = (size) => {
      this.chunkSize = parseInt(size);
      return this;
    };
    setFileId = (id) => {
      this.fileId = id;
      return this;
    };
    setHeaders = (headers) => {
      this.headers = headers ?? {};
      return this;
    };
  };
  var RemainingTimeCalculator = class {
    constructor(timeStarted, totalSize) {
      this.timeStarted = timeStarted;
      this.totalSize = totalSize;
      this.uploadedBytes = 0;
    }
    increaseBytesUploaded = (bytes) => {
      this.uploadedBytes += bytes;
      return this;
    };
    calcul = () => {
      let timeElapsed = (Date.now() - this.timeStarted.getTime()) / 1e3;
      let uploadSpeed = this.uploadedBytes / timeElapsed;
      return Math.max(Math.floor((this.totalSize - this.uploadedBytes) / uploadSpeed), 0);
    };
  };
  var UploadError = class {
    constructor(message, data) {
      this.message = message;
      this.data = data;
    }
  };
  __publicField(UploadError, "GET_LAST_CHUNK_UPLOADED", "GET_LAST_CHUNK_UPLOADED");
  __publicField(UploadError, "UPLOAD_FILE_ERROR", "UPLOAD_FILE_ERROR");
  __publicField(UploadError, "UPLOAD_ABORTED", "UPLOAD_ABORTED");
  var removeTrailingSlash = (str) => str.replace(/\/+$/, "");
  var queryParams = (query) => Object.keys(query).map((key) => `${key}=${query[key]}`).join("&");
  var throttlePause = false;
  var throttle = (callback, time = 0) => {
    return (...args) => {
      if (throttlePause)
        return;
      throttlePause = true;
      setTimeout(() => {
        callback.apply(null, args);
        throttlePause = false;
      }, time);
    };
  };
  window.Uploader = Uploader;
  window.UploadError = UploadError;
})();
